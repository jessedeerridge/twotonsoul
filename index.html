

<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>テンプレ</title>
<style>
  html, body{height:100%; overflow:hidden;}
  body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#fff;color:#111;}
  header{display:flex;justify-content:space-between;align-items:center;padding:10px 12px;border-bottom:1px solid #eee; position:sticky; top:0; z-index:10; background:#fff;}
  h1{margin:0;font-size:18px;}
  .small{font-size:12px;opacity:.75;}
  .join-box{display:flex;gap:6px;flex-wrap:wrap;align-items:center;padding:12px; position:relative; z-index:2;}
  .join-box input{padding:8px;border:1px solid #ddd;border-radius:6px;font-size:16px;}
  .btn{padding:6px 10px;border:1px solid #ddd;border-radius:6px;background:#f8f8f8;cursor:pointer;}
  .btn.primary{background:#111;color:#fff;border-color:#111;}
  .btn.ghost{background:transparent;}
  .hidden{display:none;}
  #lobby{padding:20px;border-top:1px solid #eee; position:relative; z-index:2;}
  .copy-btn.copied, .btn.ghost.copied{background:#16a34a;color:#fff;border-color:#16a34a;}

  main{
    position:relative;
    height:calc(100vh - 60px);
    overflow:auto;
    -webkit-overflow-scrolling:touch;
    background-size:cover;
    background-position:center;
    background-repeat:no-repeat;
  }
  main.prejoin{ background-image:url('maemain.jpg'); }
  main.joined{ background-image:url('maingazo.jpg'); }

  .seat-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:orange;border:1px solid #eee;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.12);
    padding:10px;z-index:20;display:flex;flex-direction:column;gap:10px;min-width:280px;
  }
  .seat-pop.hidden{display:none;}
  .seat-pop .row{display:flex;gap:8px;align-items:center;}
  .seat-pop label{width:84px;font-size:13px;}
  .seat-pop .tabs{display:flex;gap:6px;flex-wrap:wrap;}
  .tab{padding:6px 10px;border:1px solid #ddd;border-radius:999px;cursor:pointer;user-select:none;position:relative;}
  .tab.disabled{opacity:.45; pointer-events:none;}
  .tab.disabled::after{content:'✕';position:absolute;inset:0;display:grid;place-items:center;font-size:18px;font-weight:700;color:#b91c1c;pointer-events:none;}
  .tab.active{background:#111;color:#fff;border-color:#111;}

  .host-selecting-pop{
    position:fixed;left:50%;bottom:10px;transform:translateX(-50%);
    background:rgba(20,20,20,.92);color:#fff;
    padding:12px 16px;border-radius:14px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    z-index:21;font-weight:800;white-space:nowrap;
    pointer-events:none;
  }
  .host-selecting-pop.hidden{display:none;}

  .player-circle{
    position:relative;width:260px;height:260px;
    margin:20px auto 0;border-radius:50%;
    box-sizing:border-box;border:none;
  }
  .player-circle::before{content:'';}
  .player-tag{
    position:absolute;transform:translate(-50%,-50%);
    padding:4px 8px;border-radius:999px;background:#f8f8f8;
    border:1px solid #ddd;font-size:12px;white-space:nowrap;
    z-index:1;
  }

  .player-tag.me{ background:#111;color:#fff;border-color:#111; }

  .player-tag.picked{
    background:orange !important;
    color:#111 !important;
    border-color:#eab308 !important;
  }

  .player-tag .mini-hand-row{
    position:absolute;left:50%;top:100%;
    transform:translate(-50%,3px);
    display:flex;gap:6px;align-items:flex-end;
    pointer-events:none;
  }
  .mini-role-card{
    width:18px;height:26px;border-radius:5px;border:1px solid #bbb;
    background:linear-gradient(135deg,#111,#444);
    box-shadow:0 2px 6px rgba(0,0,0,.18);
    display:flex;align-items:center;justify-content:center;
    font-size:9px;font-weight:900;color:#fff;
    letter-spacing:.02em;
  }

  .player-tag .mini-hand{
    position:relative;
    width:60px;height:30px;
    pointer-events:none;
  }
  .player-tag .mini-card{
    position:absolute;left:50%;top:0;width:16px;height:22px;
    border-radius:4px;border:1px solid #bbb;
    background:linear-gradient(135deg,#e5e7eb,#cbd5f5);
    font-size:10px;display:flex;align-items:center;justify-content:center;
    transform-origin:bottom center;
    box-shadow:0 2px 6px rgba(0,0,0,.15);
  }

  /* =========================================================
     ★追加：ミニ順カード（次フェーズ：円の外側に出す）
     ========================================================= */
  .mini-order-wrap{
    position:absolute;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%);
    pointer-events:auto; /* ミニ順カード全体でクリック判定 */
    z-index:1;
  }
  .mini-role-back{
    position:absolute;
    left:-26px;
    top:50%;
    transform:translateY(-50%);
    width:64px;
    height:90px;
    border-radius:10px;
    border:1px solid rgba(255,255,255,.5);
    background:
      linear-gradient(135deg, rgba(255,255,255,.08), rgba(255,255,255,0)),
      linear-gradient(135deg,#111,#3a3a3a);
    box-shadow:0 4px 10px rgba(0,0,0,.25);
    pointer-events:none;
    z-index:2;
  }

/* ▼このブロック内の overflow を変更 */
  .mini-order-card{
    width:86px;
    height:104px;
  border-radius:14px;
  border:1px solid rgba(0,0,0,.12);
  background:linear-gradient(135deg,#ffffff,#f2f5ff);
  box-shadow:0 10px 22px rgba(0,0,0,.14);
    position:relative;
    overflow:visible; /* ★ここ：hidden → visible */
    pointer-events:auto;
  }




  .mini-order-card::after{
    content:'順';
    position:absolute;
    right:8px; top:6px;
    font-weight:900;
    font-size:12px;
    opacity:.55;
  }
  .mini-order-col{
    position:absolute;
    right:8px;
    top:12px;
    bottom:12px;
    width:48px;
    display:flex;
    flex-direction:column;
    gap:6px;
    align-items:flex-end;
    justify-content:center;
    pointer-events:auto;
  }
  .mini-order-slot{
    width:24px;
    height:14px;
    border-radius:8px;
    position:relative;
    background:rgba(255,255,255,.55);
    border:none;
    overflow:visible;
    pointer-events:auto;
  }
  .mini-order-slot .slot-border{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    pointer-events:none;
  }
  .mini-order-slot .slot-border .border-path{
    stroke: rgba(17,17,17,.22);
    stroke-width: 1px;
    stroke-dasharray: 4 4;
    fill:none;
    vector-effect: non-scaling-stroke;
    stroke-linejoin: round;
    stroke-linecap: butt;
  }
  .mini-order-chip{
    position:absolute;
    right:-24px;
    top:50%;
    transform:translateY(-50%);
    width:48px;
    height:14px;
    border-radius:8px;
    border:1px solid rgba(0,0,0,.18);
    background:#fff;
    box-shadow:0 6px 14px rgba(0,0,0,.16);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:900;
    font-size:9px;
    padding:0 3px;
    box-sizing:border-box;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    user-select:none;
    pointer-events:auto;
  }

  .mini-order-chip.hidden-chip{
    background:#2563eb;     /* 青塗り */
    border-color:#1d4ed8;
    color:#2563eb;          /* 文字は見えないように（実質無地） */
    box-shadow:0 6px 14px rgba(37,99,235,.25);
  }
  .mini-order-chip.hidden-chip::after{
    content:'';
  }
 .mini-order-chip.open-btn{
    pointer-events:auto;
    cursor:pointer;
    color:#fff;
    background:#111;
    border-color:#111;
    box-shadow:0 8px 18px rgba(0,0,0,.22);
  }
 .mini-order-chip.open-btn:active{ transform:translateY(-50%) scale(.98); }

  .mini-order-card.clickable{
    cursor:pointer;
  }

 .my-hand-wrapper{
    margin-top:6px;
    text-align:center;
    position:relative;
    z-index:60; /* 順カードより前面に固定 */
  }
  .my-hand-title{display:none;}

 .my-hand{
    display:flex;justify-content:center;gap:10px;margin-top:4px;
    min-height:90px;
    align-items:center;
    flex-wrap:wrap;
    position:relative;
    isolation:isolate;
  }

  .hand-area{
    display:flex;
    gap:10px;
    align-items:center;
    justify-content:center;
    flex-wrap:wrap;
    position:relative;
  }
  .hand-block{
    display:flex;gap:8px;
    align-items:center;
    justify-content:center;
    position:relative;
  }
  .hand-block.decided{padding:4px 4px;border-radius:10px;}
  .hand-block.pool{padding:4px 4px;border-radius:10px;}
  .hand-block.roles{padding:4px 4px;border-radius:10px;}
  .hand-block.front{z-index:6;}
  .hand-block.order-stack{z-index:1;}

  .hand-overlay{
    position:fixed;
    left:0;
    right:0;
    bottom:8px;
    padding:0 12px 12px;
    display:flex;
    justify-content:center;
    pointer-events:none;
    z-index:40;
  }
  .hand-overlay.hidden{display:none;}
  .hand-overlay .my-hand-wrapper{
    pointer-events:auto;
    margin-top:0;
  }

  body.order-open .hand-overlay{
    bottom:90px;
  }

  .my-card{
    width:60px;height:40px;border-radius:8px;border:1px solid #ddd;background:#fff;
    display:flex;align-items:center;justify-content:center;
    font-size:20px;font-weight:700;
    box-shadow:0 4px 12px rgba(0,0,0,.15);
    user-select:none;
    cursor:pointer;
    position:relative;

    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    padding:0 4px;
    box-sizing:border-box;
  }
  .my-card.smalltxt{font-size:16px;}
  .my-card.disabled{opacity:.55; cursor:default;}
  .my-card.current{
    outline:3px solid rgba(255,165,0,.75);
    outline-offset:2px;
  }

  @keyframes pulseCard{
    0%{transform:scale(1);}
    50%{transform:scale(1.08);}
    100%{transform:scale(1);}
  }
  .my-card.undecided{
    animation:pulseCard .85s ease-in-out infinite;
  }

  .pool-wrap{
    display:flex;gap:8px;align-items:center;justify-content:center;
    transform:translateX(0);
    opacity:1;
    transition:transform .45s ease, opacity .45s ease;
    will-change:transform, opacity;
  }
  .pool-wrap.passing-out{
    transform:translateX(110px);
    opacity:0;
  }

  @keyframes incomingFromLeft{
    0%{transform:translateX(-120px); opacity:0;}
    100%{transform:translateX(0); opacity:1;}
  }
  .pool-wrap.incoming{
    animation:incomingFromLeft .45s ease both;
  }

  .role-card-big{
    width:64px;height:90px;border-radius:10px;border:1px solid #ddd;
    background:linear-gradient(135deg,#f8fafc,#eef2ff);
    box-shadow:0 6px 16px rgba(0,0,0,.12);
    display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:900;color:#111;
    padding:6px;
    text-align:center;
    user-select:none;
    position:relative;
    box-sizing:border-box;
  }

  /* ★順カード小のとき：正体カードを左に“重ねる” */
  .role-card-big.overlap-left{
    margin-right:-26px;   /* 重ねる量（調整可） */
    z-index:3;            /* order-smallより前 */
  }
  .order-card-small{position:relative; z-index:2;}

  /* ★①：順カード拡大時：正体カードを「順カードの左で重ねる」 */
  .role-float{
    position:fixed;
    --rfw: 128px;
    --rfh: 176px;
    width:var(--rfw);
    height:var(--rfh);

    left:50%;
    top:50%;

    /* 順カード(幅260)の左側へ：中心から-154pxずらす（左で重ねる） */
    transform:translate(-50%,-50%) translateX(-154px);

    z-index:26;
    pointer-events:none;
    border-radius:16px;
    font-size:16px;
    box-shadow:0 14px 30px rgba(0,0,0,.20);
  }

  .dialog-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:center;justify-content:center;z-index:15;
  }
  .dialog-backdrop.hidden{display:none;}
  .dialog-box{
    background:#fff;border-radius:12px;padding:16px 18px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    max-width:320px;width:calc(100% - 40px);
  }
  .dialog-box p{margin:0 0 12px;font-size:14px;line-height:1.6;}
  .dialog-buttons{display:flex;justify-content:flex-end;gap:8px;}

  .host-settings-btn{
    position:fixed;right:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #ddd;background:#fff;box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;font-size:22px;cursor:pointer;z-index:22;
  }
  .host-settings-btn.visible{display:flex;}

  .start-pop{
    position:fixed;right:16px;bottom:72px;background:#fff;border:1px solid #ddd;border-radius:12px;
    box-shadow:0 12px 28px rgba(0,0,0,.16);padding:10px 12px;z-index:23;min-width:260px;
    display:flex;flex-direction:column;gap:8px;
  }
  .start-pop.hidden{display:none;}
  .start-pop-header{display:flex;justify-content:space-between;align-items:center;gap:8px;}
  .start-pop-title{font-size:14px;font-weight:600;}
  .start-pop-main{font-size:13px;line-height:1.5;}
  .start-pop-actions{display:flex;justify-content:flex-end;gap:8px;margin-top:4px;flex-wrap:wrap;}

  #roomInfoLobby, #lobby h2, #lobby p {display:none;}
  #lobby.entered{
    display:flex;flex-direction:column;align-items:center;justify-content:center;
    min-height:calc(100vh - 60px);
  }

  .help-btn{
    position:fixed;left:16px;bottom:16px;width:44px;height:44px;border-radius:50%;
    border:1px solid #111;background:#111;color:#fff;
    box-shadow:0 8px 20px rgba(0,0,0,.18);
    display:none;align-items:center;justify-content:center;
    font-size:22px;font-weight:800;cursor:pointer;z-index:22;
  }
  .help-btn.visible{display:flex;}

  .help-pop-backdrop{
    position:fixed;inset:0;background:rgba(0,0,0,.35);
    display:flex;align-items:flex-end;justify-content:center;
    z-index:16;
    padding:16px;
  }
  .help-pop-backdrop.hidden{display:none;}
  .help-pop{
    width:min(520px, calc(100% - 0px));
    max-height:min(70vh, 640px);
    background:#fff;border:1px solid #ddd;border-radius:16px;
    box-shadow:0 18px 40px rgba(0,0,0,.35);
    overflow:hidden;
  }
  .help-pop-header{
    display:flex;align-items:center;justify-content:space-between;
    padding:10px 12px;border-bottom:1px solid #eee;
  }
  .help-pop-title{font-weight:800;font-size:14px;}
  .help-pop-body{padding:12px;overflow:auto;max-height:calc(70vh - 48px);}
  .role-row{
    display:flex;gap:12px;align-items:flex-start;
    padding:10px 0;
  }
  .role-card{
    width:72px;height:108px;border-radius:10px;border:1px solid #ddd;background:#f8f8f8;
    box-shadow:0 6px 16px rgba(0,0,0,.10);
    flex:0 0 auto;
    display:flex;align-items:center;justify-content:center;
    font-size:12px;font-weight:700;color:#444;
    text-align:center;padding:6px;
  }
  .role-desc{flex:1 1 auto;}
  .role-desc .name{font-weight:900;margin-bottom:4px;}
  .role-desc .text{font-size:13px;line-height:1.55;color:#222;white-space:pre-wrap;}

  /* =========================================================
     ★ 追加：順カード（大/小）UI
     ========================================================= */

  .order-big{
    position:fixed;
    left:50%; top:50%;
    transform:translate(-50%,-50%);
    z-index:5;
    pointer-events:auto;
  }
  .order-big.hidden{display:none;}

  .order-card-big{
    width:260px; height:360px;
    border-radius:18px;
    border:1px solid rgba(0,0,0,.12);
    background:linear-gradient(135deg,#ffffff,#f2f5ff);
    box-shadow:0 22px 60px rgba(0,0,0,.30);
    position:relative;
    overflow:visible;
    user-select:none;
  }
  .order-card-big::after{
    content:'順カード';
    position:absolute;
    right:10px; top:10px;
    font-weight:900;
    font-size:14px;
    opacity:.55;
    letter-spacing:.08em;
  }

  .order-hint{
    position:absolute;
    left:12px; right:12px;
    bottom:10px;
    font-size:12px;
    opacity:.65;
    line-height:1.35;
    text-align:center;
    pointer-events:none;
  }

  .order-slot-col{
    position:absolute;
    right:0;
    left:auto;
    top:54px;
    bottom:44px;
    width:88px;
    display:flex;
    flex-direction:column;
    gap:10px;
    align-items:flex-end;
    padding-right:10px;
  }

  /* ★点線枠：SVGで「上→左→下」の一本線（右辺なし） */
  .order-slot{
    --slot-border: rgba(17,17,17,.22);
    --slot-bw: 2px;

    width:44px;
    height:44px;
    border-radius:12px;
    position:relative;
    box-sizing:border-box;
    overflow:visible;
    background:rgba(255,255,255,.55);

    border:none;
  }

  .order-slot.over{
    --slot-border: rgba(255,165,0,.78);
    background:rgba(255,165,0,.10);
  }

  .order-slot .slot-border{
    position:absolute;
    inset:0;
    width:100%;
    height:100%;
    pointer-events:none;
  }
  .order-slot .slot-border .border-path{
    stroke: var(--slot-border);
    stroke-width: var(--slot-bw);
    stroke-dasharray: 7 7;
    fill:none;
    vector-effect: non-scaling-stroke;
    stroke-linejoin: round;
    stroke-linecap: butt;
  }

  .order-in-slot{
    position:absolute;
    right:-40px;
    left:auto;
    top:50%;
    transform:translateY(-50%);
    width:80px;
    height:44px;
    border-radius:12px;
    border:1px solid rgba(0,0,0,.18);
    background:#fff;
    box-shadow:0 10px 24px rgba(0,0,0,.18);
    display:flex;
    align-items:center;
    justify-content:center;
    font-weight:800;
    font-size:16px;
    padding:0 6px;
    box-sizing:border-box;
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    cursor:grab;
  }
  .order-in-slot:active{cursor:grabbing;}
  .order-pointer-draggable{
    touch-action:none;
    cursor:grab;
  }
  .order-pointer-draggable:active{cursor:grabbing;}
  .drag-ghost{
    position:fixed;
    left:0;
    top:0;
    transform:translate(-50%,-50%);
    pointer-events:none;
    z-index:30;
    opacity:.92;
  }

  /* ★順カード小：① 幅を少し小さく */
  .order-card-small{
    width:86px;           /* ★① 96→86 */
    height:104px;
    border-radius:14px;
    border:1px solid rgba(0,0,0,.12);
    background:linear-gradient(135deg,#ffffff,#f2f5ff);
    box-shadow:0 10px 22px rgba(0,0,0,.14);
    position:relative;
    overflow:visible;
    cursor:pointer;
    user-select:none;
  }
  .order-card-small::after{
    content:'順';
    position:absolute;
    right:8px; top:6px;
    font-weight:900;
    font-size:12px;
    opacity:.55;
  }

  .order-slot-col.small{
    top:12px; bottom:12px;
    width:48px;          /* ★① 52→48 */
    padding-right:8px;
    padding-left:0;
    gap:6px;
    right:0; left:auto;
    align-items:flex-end;
  }

  .order-slot.small{
    --slot-bw: 1px;
    width:24px;          /* ★① 26→24 */
    height:14px;
    border-radius:8px;
    position:relative;
    box-sizing:border-box;
    overflow:visible;
    background:rgba(255,255,255,.55);
    border:none;
  }
  .order-slot.small .slot-border .border-path{
    stroke-dasharray: 4 4;
  }

  .order-in-slot.small{
    right:-24px;         /* ★① 26→24 */
    left:auto;
    width:48px;          /* ★① 52→48 */
    height:14px;
    border-radius:8px;
    font-size:9px;
    box-shadow:0 6px 14px rgba(0,0,0,.16);
    padding:0 3px;
  }

  .hand-block.decided.drop-over{
    outline:2px dashed rgba(255,165,0,.65);
    outline-offset:4px;
    border-radius:12px;
  }

/* ★拡大中は「自分の」ミニ順カードを消す（2枚見える問題の解消） */
body.order-open .mini-order-wrap.me{
  display:none;
}




</style>
</head>
<body>

<header>
  <h1>テンプレ</h1>
  <div style="display:flex;align-items:center;gap:6px;">
    <div class="small" id="roomInfo"></div>
    <button class="btn ghost" id="copyLinkBtn">リンクコピー</button>
  </div>
</header>

<main id="main" class="prejoin">
  <div class="join-box" id="joinBox">
    <input id="userName" placeholder="名前（4文字以内）" maxlength="4" />
    <input id="roomCode" placeholder="ルームコード（未入力で自動生成）" maxlength="12" />
    <button class="btn primary" id="btnJoin">入室</button>
  </div>

  <div id="lobby" class="hidden">
    <h2>ロビー</h2>
    <div id="roomInfoLobby" style="margin-bottom:8px;"></div>
    <p>ここにテーブルや情報が表示されます。</p>

    <div id="playerCircle" class="player-circle"></div>

    <div class="my-hand-wrapper">
      <div class="my-hand-title">自分のカード</div>
      <div id="myHand" class="my-hand"></div>
    </div>
  </div>
</main>

<div id="hostSelectingPop" class="host-selecting-pop hidden">ホストが人数を選択中</div>

<div id="seatPop" class="seat-pop hidden">
  <div class="row"><label>席を選択</label><div id="seatTabs" class="tabs"></div></div>
  <div class="row" style="justify-content:flex-end">
    <button class="btn small ghost" id="btnSeatCancel">観戦</button>
  </div>
</div>

<div id="kickDialog" class="dialog-backdrop hidden">
  <div class="dialog-box" id="kickDialogBox">
    <p id="kickMessage">既存のプレイヤーを追い出して、着席しますか？</p>
    <div class="dialog-buttons">
      <button class="btn ghost" id="btnKickNo">いいえ</button>
      <button class="btn primary" id="btnKickYes">はい</button>
    </div>
  </div>
</div>

<button id="hostSettingsBtn" class="host-settings-btn" title="設定">⚙</button>

<button id="helpBtn" class="help-btn" title="正体カード一覧">？</button>

<div id="helpBackdrop" class="help-pop-backdrop hidden">
  <div class="help-pop" role="dialog" aria-modal="true" aria-label="正体カード一覧">
    <div class="help-pop-header">
      <div class="help-pop-title">正体カード</div>
      <button id="btnHelpClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
    </div>
    <div class="help-pop-body" id="helpBody"></div>
  </div>
</div>

<div id="startPop" class="start-pop hidden">
  <div class="start-pop-header">
    <div class="start-pop-title">ホスト設定</div>
    <button id="btnStartPopClose" class="btn ghost" style="padding:2px 6px;font-size:12px;">×</button>
  </div>
  <div class="start-pop-main">
    「スタート」で全プレイヤーに<br>
    役職カード1枚 + 手札カード5枚（ドラフト開始）を配布。<br>
    「リセット」で人数選択へ戻します（内容は後で）。
  </div>
  <div class="start-pop-actions">
    <button id="btnResetRoom" class="btn ghost">リセット</button>
    <button id="btnGameStart" class="btn primary">スタート</button>
  </div>
</div>

<div id="orderBig" class="order-big hidden" aria-label="順カード（並び替え）">
  <div id="orderBigCard" class="order-card-big">
    <div id="orderSlotsBig" class="order-slot-col"></div>
    <div class="order-hint">下の「決定カード」からドラッグして右側の5枠へ。<br>枠内でドラッグして並び替えもできます。</div>
  </div>
</div>
<div id="handOverlay" class="hand-overlay hidden" aria-hidden="true"></div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
import {
  getDatabase, ref, set, get, update, onValue, remove, runTransaction
} from "https://www.gstatic.com/firebasejs/9.23.0/firebase-database.js";

const firebaseConfig = {
  apiKey: "AIzaSyAMeKfMoHt9qO2VuUBpkrKuei7yGBbEi8",
  authDomain: "cheesetheft-fd52f.firebaseapp.com",
  databaseURL: "https://cheesetheft-fd52f-default-rtdb.firebaseio.com",
  projectId: "cheesetheft-fd52f",
  storageBucket: "cheesetheft-fd52f.firebasestorage.app",
  messagingSenderId: "298688959395",
  appId: "1:298688959395:web:6ac2c3eb214201f2020016",
  measurementId: "G-HPDFTCLR8H"
};

const app = initializeApp(firebaseConfig);
const db  = getDatabase(app);

const savedUserId = sessionStorage.getItem('bbUserId') || crypto.randomUUID();
sessionStorage.setItem('bbUserId', savedUserId);

const ROLE_CARDS = ["医者","先生","カブトムシ","飛行機","ドラキュラ"];
const HAND_DECK = [
  "aa","bb","cc","dd","ee","ff","gg","hh","ii","jj","kk","ll","mm","oo","pp","qq","rr","ss","tt","uu",
  "vv","ww","zz","ab","zc","rg","jy","4r","qw","jy","id","hg","kj","er","yh","gf","zx","mj"
];

const state = {
  userId: savedUserId,
  userName: null,
  roomCode: null,
  seatedTable: null,
  isHost: false,
  hands: {},
  room: {},
  draft: null,

  // ★追加：順カード確定内容（全員分）
  orders: {},

  _lastIncomingToken: null,
  _lastPassToken: null,

  order: {
    decidedKey: null,
    decidedObjs: [],
    slots: Array(5).fill(null),
    completed: false,
    open: false,
    _autoOpenedOnce: false,
    dragging: null,

    // ★追加：自分の順カード「確定」(DBに書いたらロック)
    submitted: false,
    submittedOrder: null,
  }
};

const mainEl = document.getElementById('main');
const joinBox = document.getElementById('joinBox');
const inputName = document.getElementById('userName');
const inputCode = document.getElementById('roomCode');
const btnJoin = document.getElementById('btnJoin');
const lobby = document.getElementById('lobby');
const roomInfo = document.getElementById('roomInfo');
const roomInfoLobby = document.getElementById('roomInfoLobby');
const copyLinkBtn = document.getElementById('copyLinkBtn');

const hostSelectingPop = document.getElementById('hostSelectingPop');
const seatPop = document.getElementById('seatPop');
const seatTabs = document.getElementById('seatTabs');
const btnSeatCancel = document.getElementById('btnSeatCancel');
const seatLabel = seatPop.querySelector('label');

const playerCircle = document.getElementById('playerCircle');
const myHandEl = document.getElementById('myHand');
const myHandWrapper = document.querySelector('.my-hand-wrapper');
const handOverlay = document.getElementById('handOverlay');
const handAnchor = document.createComment('hand-anchor');
if (myHandWrapper?.parentElement){
  myHandWrapper.parentElement.insertBefore(handAnchor, myHandWrapper.nextSibling);
}

const kickDialog = document.getElementById('kickDialog');
const kickMessage = document.getElementById('kickMessage');
const btnKickYes = document.getElementById('btnKickYes');
const btnKickNo = document.getElementById('btnKickNo');

const hostSettingsBtn = document.getElementById('hostSettingsBtn');
const startPop = document.getElementById('startPop');
const btnStartPopClose = document.getElementById('btnStartPopClose');
const btnGameStart = document.getElementById('btnGameStart');
const btnResetRoom = document.getElementById('btnResetRoom');

const helpBtn = document.getElementById('helpBtn');
const helpBackdrop = document.getElementById('helpBackdrop');
const btnHelpClose = document.getElementById('btnHelpClose');
const helpBody = document.getElementById('helpBody');

const ROLE_HELP = ROLE_CARDS.map(n => ({ name:n, text:"（説明は後で追加）" }));

const orderBigWrap = document.getElementById('orderBig');
const orderSlotsBig = document.getElementById('orderSlotsBig');
const orderBigCard = document.getElementById('orderBigCard');

/* =========================
   ★追加：点線SVGを注入（右辺なし＝一本線）
   ========================= */
function injectSlotBorder(slotEl){
  if (slotEl.querySelector('.slot-border')) return;

  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, 'svg');
  svg.classList.add('slot-border');
  svg.setAttribute('viewBox', '0 0 100 100');
  svg.setAttribute('preserveAspectRatio', 'none');

  const path = document.createElementNS(svgNS, 'path');
  path.classList.add('border-path');

  path.setAttribute('d', 'M 99 1 H 19 A 18 18 0 0 0 1 19 V 81 A 18 18 0 0 0 19 99 H 99');

  svg.appendChild(path);
  slotEl.appendChild(svg);
}

/* =========================
   ★重要：bodyに残った「中央固定の正体カード」を毎回掃除
   ========================= */
function cleanupFloatingRole(){
  document.querySelectorAll('.role-float').forEach(el => el.remove());
}

/* =========================
   ★② 重要：小さい順カード（order-card-small）を場から完全に消す（保険）
   ========================= */
function cleanupOrderSmallArtifacts(){
  document.querySelectorAll('.order-card-small, .order-slot-col.small').forEach(el=>{
    el.remove?.();
  });
}

function renderHelpList(){
  helpBody.innerHTML = '';
  ROLE_HELP.forEach((r) => {
    const row = document.createElement('div');
    row.className = 'role-row';

    const card = document.createElement('div');
    card.className = 'role-card';
    card.textContent = r.name;

    const desc = document.createElement('div');
    desc.className = 'role-desc';
    desc.innerHTML = `
      <div class="name">${r.name}</div>
      <div class="text">${r.text}</div>
    `;
    row.appendChild(card);
    row.appendChild(desc);
    helpBody.appendChild(row);
  });
}
function openHelp(){ renderHelpList(); helpBackdrop.classList.remove('hidden'); }
function closeHelp(){ helpBackdrop.classList.add('hidden'); }
helpBtn.addEventListener('click', () => { if (joinBox.classList.contains('hidden')) openHelp(); });
btnHelpClose.addEventListener('click', closeHelp);
helpBackdrop.addEventListener('click', (e) => { if (e.target === helpBackdrop) closeHelp(); });

let pendingSeatIndexToSteal = null;
let pendingSeatPlayerIdToSteal = null;
let isRenderingSeatTabs = false;
let latestPlayers = [];
let hostPassTimer = null;

function generateRoomCode(length = 6){
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let code = '';
  for(let i=0;i<length;i++) code += chars.charAt(Math.floor(Math.random()*chars.length));
  return code;
}
function shuffle(arr){
  const a = arr.slice();
  for(let i=a.length-1;i>0;i--){
    const j = Math.floor(Math.random()*(i+1));
    [a[i],a[j]] = [a[j],a[i]];
  }
  return a;
}
function sampleWithoutReplacement(arr, k){ return shuffle(arr).slice(0, Math.min(k, arr.length)); }
function dealPool5(){
  const out = [];
  for(let i=0;i<5;i++) out.push(HAND_DECK[Math.floor(Math.random()*HAND_DECK.length)]);
  return out;
}
function makeRoleListForN(n){
  if (n <= 0) return [];
  if (n % 2 === 0){
    const needPairs = n/2;
    const roles = sampleWithoutReplacement(ROLE_CARDS, needPairs);
    return shuffle(roles.flatMap(r => [r,r]));
  } else {
    const needPairs = (n-1)/2;
    const pairRoles = sampleWithoutReplacement(ROLE_CARDS, needPairs);
    const remaining = ROLE_CARDS.filter(r => !pairRoles.includes(r));
    const single = remaining.length ? remaining[Math.floor(Math.random()*remaining.length)] : null;
    return shuffle(pairRoles.flatMap(r => [r,r]).concat(single ? [single] : []));
  }
}

function refreshRoomLabels(){
  if (!state.roomCode || !state.userName) return;
  const label = state.isHost ? '（ホスト）' : '';
  const infoText = ` ${state.roomCode},  ${state.userName}${label}`;
  roomInfo.textContent = infoText;
  roomInfoLobby.textContent = infoText;
}
function updateHostUI(){
  refreshRoomLabels();
  if (state.isHost) hostSettingsBtn.classList.add('visible');
  else { hostSettingsBtn.classList.remove('visible'); startPop.classList.add('hidden'); }
  helpBtn.classList.add('visible');
}

/* =========================
   ★フェーズ補助
   ========================= */
function getRoomPhase(){
  return state.room?.phase || null; // "draft" | "order" | "reveal" | null
}
function getRevealIndex(){
  const v = state.room?.revealIndex;
  return Number.isInteger(v) ? v : 0; // 0..5
}
function canEditOrder(){
  const phase = getRoomPhase();
  return phase === 'order' || phase === 'reveal';
}

/* =========================
   ★順カード確定（自分）をDBへ
   ========================= */
function cardTextById(cardId){
  const o = state.order.decidedObjs.find(x => x.id === cardId);
  return o ? o.text : '';
}
function computeLocalOrderedTexts(){
  if (!Array.isArray(state.order.slots) || state.order.slots.length !== 5) return null;
  if (!state.order.slots.every(v => v)) return null;
  const out = state.order.slots.map(cid => cardTextById(cid)).map(t => (t ?? '').trim());
  if (out.some(t => !t)) return null;
  return out;
}
function areTextArraysEqual(a, b){
  if (!Array.isArray(a) || !Array.isArray(b)) return false;
  if (a.length !== b.length) return false;
  return a.every((v, i) => v === b[i]);
}
async function submitMyOrderIfReady(){
  if (!state.roomCode) return;
  if (!canEditOrder()) return;
  if (!state.order.completed) return;

  const ordered = computeLocalOrderedTexts();
  if (!ordered) return;
  if (state.order.submitted && areTextArraysEqual(state.order.submittedOrder, ordered)) return;

  const myId = state.userId;
  await set(ref(db, `rooms/${state.roomCode}/orders/${myId}`), {
    ordered,
    submittedAt: Date.now(),
    name: state.userName || ''
  });

  state.order.submitted = true;
  state.order.submittedOrder = ordered.slice();
}

/* =========================
   ★ホスト：全員の確定を検知して次フェーズへ
   - 全員が orders/{pid}.ordered(5枚) を持っていたら phase="reveal"
   ========================= */
function getSeatedPlayerIds(){ return latestPlayers.map(p => p.id); }

async function hostMaybeEnsureOrderPhase(){
  if (!state.isHost) return;
  if (!state.roomCode) return;
  // ドラフトが終わっているのに phase が未設定なら "order" にする
  if (!state.draft || state.draft.phase !== 'done') return;
  const phase = getRoomPhase();
  if (phase === 'order' || phase === 'reveal') return;

  await update(ref(db, `rooms/${state.roomCode}`), {
    phase: 'order',
    revealIndex: 0
  });
}

function hasSubmittedOrderFor(pid){
  const o = state.orders?.[pid];
  return Array.isArray(o?.ordered) && o.ordered.length === 5;
}

async function hostMaybeAdvanceToReveal(){
  if (!state.isHost) return;
  if (!state.roomCode) return;
  if (getRoomPhase() !== 'order') return;

  const ids = getSeatedPlayerIds();
  if (!ids.length) return;

  const allDone = ids.every(pid => hasSubmittedOrderFor(pid));
  if (!allDone) return;

  await update(ref(db, `rooms/${state.roomCode}`), {
    phase: 'reveal',
    revealIndex: 0,
    revealStartedAt: Date.now()
  });
}

/* =========================
   ★ホスト：次の段階公開（全員の同じ段）
   ========================= */
async function hostRevealNext(){
  if (!state.isHost) return;
  if (!state.roomCode) return;
  await runTransaction(ref(db, `rooms/${state.roomCode}`), (cur) => {
    if (!cur) return cur;
    if (cur.phase !== 'reveal') return cur;
    const idx = Number.isInteger(cur.revealIndex) ? cur.revealIndex : 0;
    if (idx >= 5) return cur;
    return { ...cur, revealIndex: idx + 1, revealUpdatedAt: Date.now() };
  });
}

function subscribeRoom(){
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  onValue(roomRef, snap => {
    state.room = snap.val() || {};
    const waiting = (!state.isHost && !state.room.maxPlayers);
    hostSelectingPop.classList.toggle('hidden', !waiting);
    syncSeatUI();

    // ★ホスト：ドラフト完了後に order フェーズを保証
    hostMaybeEnsureOrderPhase();
    // ★ホスト：全員確定なら revealへ
    hostMaybeAdvanceToReveal();

    // UI更新（ミニ順カード表示など）
    renderHands();
  });
}
function subscribeHostState(){
  const hostRef = ref(db, `rooms/${state.roomCode}/hostId`);
  onValue(hostRef, snap => {
    const hostId = snap.val();
    state.isHost = (hostId === state.userId);
    updateHostUI();
    syncSeatUI();
    hostMaybeAdvanceDraft();
    hostMaybeEnsureOrderPhase();
    hostMaybeAdvanceToReveal();
  });
}
function subscribeHands(){
  const handsRef = ref(db, `rooms/${state.roomCode}/hands`);
  onValue(handsRef, snap => {
    state.hands = snap.val() || {};
    renderHands();
    hostMaybeAdvanceDraft();
    hostMaybeEnsureOrderPhase();
    hostMaybeAdvanceToReveal();
  });
}
function subscribeDraft(){
  const draftRef = ref(db, `rooms/${state.roomCode}/draft`);
  onValue(draftRef, snap => {
    state.draft = snap.val() || null;
    renderHands();
    hostMaybeAdvanceDraft();
    hostMaybeEnsureOrderPhase();
    hostMaybeAdvanceToReveal();
  });
}
function subscribeOrders(){
  const ordersRef = ref(db, `rooms/${state.roomCode}/orders`);
  onValue(ordersRef, snap => {
    state.orders = snap.val() || {};

    // ★自分が既に確定済みならローカルもロック
    const my = state.orders?.[state.userId];
    if (Array.isArray(my?.ordered) && my.ordered.length === 5){
      state.order.submitted = true;
      state.order.submittedOrder = my.ordered.slice();
    }

    renderHands();
    hostMaybeAdvanceToReveal();
  });
}

function computeAllPicked(){
  if (!state.draft || state.draft.phase !== 'draft') return false;
  if (state.draft.status !== 'picking') return false;
  const ids = getSeatedPlayerIds();
  if (!ids.length) return false;
  return ids.every(pid => {
    const h = state.hands[pid];
    return h && Number.isInteger(h.pickIdx);
  });
}

function fitCardText(el){
  el.style.fontSize = '';
  el.style.letterSpacing = '';
  el.style.transform = '';

  const cs = getComputedStyle(el);
  const maxW = el.clientWidth - 8;
  let size = parseFloat(cs.fontSize) || 16;

  let guard = 0;
  while (el.scrollWidth > maxW && size > 9 && guard < 50){
    size -= 1;
    el.style.fontSize = size + 'px';
    guard++;
  }
  if (el.scrollWidth > maxW){
    el.style.letterSpacing = '-0.03em';
  }
}
function fitAllMyCards(){
  myHandEl.querySelectorAll('.my-card').forEach(fitCardText);
}

function decidedKeyFromArray(arr){
  return Array.isArray(arr) ? arr.join('||') : '';
}
function mapSubmittedOrderToSlots(decidedObjs, submittedOrder){
  if (!Array.isArray(decidedObjs) || !Array.isArray(submittedOrder)) return null;
  if (submittedOrder.length !== 5) return null;
  const used = new Set();
  const mapped = submittedOrder.map((text) => {
    const idx = decidedObjs.findIndex((o, i) => !used.has(i) && o.text === text);
    if (idx < 0) return null;
    used.add(idx);
    return decidedObjs[idx].id;
  });
  if (mapped.some(v => !v)) return null;
  return mapped;
}

function ensureOrderStateForMyHand(h){
  const decided = Array.isArray(h?.decided) ? h.decided : [];
  const draftDone = !!state.draft && state.draft.phase === 'done';

  // 並び替え不可のフェーズなら閉じる
  if (!canEditOrder()){
    state.order.open = false;
    hideOrderBig();
  }

  if (!draftDone || decided.length < 5){
    state.order.decidedKey = null;
    state.order.decidedObjs = [];
    state.order.slots = Array(5).fill(null);
    state.order.completed = false;
    state.order.open = false;
    state.order._autoOpenedOnce = false;
    state.order.submitted = false;
    state.order.submittedOrder = null;
    hideOrderBig();
    return;
  }

  const key = decidedKeyFromArray(decided);
  if (state.order.decidedKey !== key){
    state.order.decidedKey = key;
    state.order.decidedObjs = decided.slice(0,5).map((text, i) => ({ id:`d${i}`, text }));
    const validIds = new Set(state.order.decidedObjs.map(o=>o.id));
    state.order.slots = state.order.slots.map(cid => validIds.has(cid) ? cid : null);
    const submittedSlots = mapSubmittedOrderToSlots(state.order.decidedObjs, state.order.submittedOrder);
    if (submittedSlots){
      state.order.slots = submittedSlots;
      state.order.completed = true;
    } else {
      state.order.completed = state.order.slots.every(v => v);
    }

    if (canEditOrder()){
      if (!state.order.completed && !state.order._autoOpenedOnce){
        state.order._autoOpenedOnce = true;
        showOrderBig();
      }
    } else {
      hideOrderBig();
    }
  }

  if (state.order.submittedOrder && state.order.decidedObjs.length === 5 && state.order.slots.every(v => !v)){
    const submittedSlots = mapSubmittedOrderToSlots(state.order.decidedObjs, state.order.submittedOrder);
    if (submittedSlots){
      state.order.slots = submittedSlots;
      state.order.completed = true;
    }
  }

  if (canEditOrder()){
    if (!state.order.completed){
      showOrderBig();
    } else {
      if (state.order.open) showOrderBig();
      else hideOrderBig();
    }
  } else {
    hideOrderBig();
  }
}

function safeParseDragPayload(s){
  try{
    const o = JSON.parse(s);
    return o && typeof o === 'object' ? o : null;
  } catch {
    return null;
  }
}

/* =========================
   ★⑤ 閉じる条件を厳密に：
   - 「順カード（大）」「順カード（小）」「手札エリア（myHandWrapper）」を触ってる間は閉じない
   - それ以外を触ったら閉じる
   ========================= */
function isInsideOrderOrHand(target){
  if (!target) return false;
  if (orderBigWrap && !orderBigWrap.classList.contains('hidden') && orderBigWrap.contains(target)) return true;
  if (target.closest?.('.order-card-small')) return true;
  if (myHandWrapper && myHandWrapper.contains(target)) return true;
  return false;
}

function showOrderBig(){
  if (!canEditOrder()) return; // ★orderフェーズ & 未確定のみ編集OK
  state.order.open = true;

  /* ★②：大を出す前に小の残骸が場に残っていたら消す（保険） */
  cleanupOrderSmallArtifacts();

  orderBigWrap.classList.remove('hidden');
  setOrderOpen(true);
  renderOrderBigSlots();
}
function hideOrderBig(){
  orderBigWrap.classList.add('hidden');
  setOrderOpen(false);
  cleanupFloatingRole();
}
function toggleOrderBig(){
  if (!state.order.completed) return;
  if (!canEditOrder()) return;
  state.order.open = !state.order.open;
  if (state.order.open) showOrderBig();
  else hideOrderBig();
  renderMyHand();
}

function renderOrderBigSlots(){
  orderSlotsBig.innerHTML = '';

  for(let i=0;i<5;i++){
    const slot = document.createElement('div');
    slot.className = 'order-slot';
    slot.dataset.idx = String(i);

    injectSlotBorder(slot);

    slot.addEventListener('dragover', (e) => {
      if (!canEditOrder()) return;
      e.preventDefault();
      slot.classList.add('over');
    });
    slot.addEventListener('dragleave', () => slot.classList.remove('over'));
    slot.addEventListener('drop', (e) => {
      if (!canEditOrder()) return;
      e.preventDefault();
      slot.classList.remove('over');
      const payload = safeParseDragPayload(e.dataTransfer?.getData('text/plain') || '');
      if (!payload || payload.type !== 'orderCard' || !payload.cardId) return;

      placeCardIntoSlot(payload.cardId, i, payload.fromSlotIdx);
    });

    const cid = state.order.slots[i];
    if (cid){
      const chip = document.createElement('div');
      chip.className = 'order-in-slot';
      chip.textContent = cardTextById(cid);
      chip.draggable = false;
      if (canEditOrder()){
        setupPointerDrag(chip, { cardId: cid, fromSlotIdx: i });
      } else {
        chip.style.cursor = 'default';
      }
      slot.appendChild(chip);
    }

    orderSlotsBig.appendChild(slot);
  }
}

function setOrderOpen(isOpen){
  document.body.classList.toggle('order-open', isOpen);
  if (!myHandWrapper || !handOverlay || !handAnchor.parentElement) return;
  if (isOpen){
    handOverlay.classList.remove('hidden');
    handOverlay.appendChild(myHandWrapper);
  } else {
    handOverlay.classList.add('hidden');
    handAnchor.parentElement.insertBefore(myHandWrapper, handAnchor);
  }
}

function setupPointerDrag(el, { cardId, fromSlotIdx }){
  if (!canEditOrder()) return;
  el.classList.add('order-pointer-draggable');
  el.addEventListener('pointerdown', (e) => {
    if (!canEditOrder()) return;
    if (e.button !== 0 && e.pointerType !== 'touch') return;
    e.preventDefault();
    e.stopPropagation();
    startPointerDrag(e, { cardId, fromSlotIdx, sourceEl: el });
  });
}

function startPointerDrag(e, { cardId, fromSlotIdx, sourceEl }){
  if (!canEditOrder()) return;
  if (state.order.dragging) return;
  const rect = sourceEl.getBoundingClientRect();
  const ghost = sourceEl.cloneNode(true);
  ghost.classList.add('drag-ghost');
  ghost.style.width = `${rect.width}px`;
  ghost.style.height = `${rect.height}px`;
  ghost.style.left = `${e.clientX}px`;
  ghost.style.top = `${e.clientY}px`;
  document.body.appendChild(ghost);

  const dragState = {
    cardId,
    fromSlotIdx,
    pointerId: e.pointerId,
    ghostEl: ghost
  };
  state.order.dragging = dragState;

  sourceEl.setPointerCapture(e.pointerId);
  window.addEventListener('pointermove', onPointerDragMove);
  window.addEventListener('pointerup', onPointerDragEnd);
  window.addEventListener('pointercancel', onPointerDragEnd);
}

function getOrderSlotAtPoint(x, y){
  const el = document.elementFromPoint(x, y);
  const slot = el?.closest?.('.order-slot') || null;
  if (slot && orderBigWrap.contains(slot)) return slot;
  return null;
}

function clearSlotHighlights(){
  document.querySelectorAll('.order-slot.over').forEach(el => el.classList.remove('over'));
}

function onPointerDragMove(e){
  const dragState = state.order.dragging;
  if (!dragState || dragState.pointerId !== e.pointerId) return;
  if (dragState.ghostEl){
    dragState.ghostEl.style.left = `${e.clientX}px`;
    dragState.ghostEl.style.top = `${e.clientY}px`;
  }

  clearSlotHighlights();
  const slot = getOrderSlotAtPoint(e.clientX, e.clientY);
  if (slot) slot.classList.add('over');
}

function onPointerDragEnd(e){
  const dragState = state.order.dragging;
  if (!dragState || dragState.pointerId !== e.pointerId) return;

  clearSlotHighlights();

  const slot = getOrderSlotAtPoint(e.clientX, e.clientY);
  if (slot){
    const idx = Number(slot.dataset.idx);
    placeCardIntoSlot(dragState.cardId, idx, dragState.fromSlotIdx);
  } else {
    const target = document.elementFromPoint(e.clientX, e.clientY);
    const decidedBlock = target?.closest?.('.hand-block.decided');
    if (decidedBlock && Number.isInteger(dragState.fromSlotIdx)){
      removeCardFromSlots(dragState.cardId);
    }
  }

  if (dragState.ghostEl) dragState.ghostEl.remove();
  state.order.dragging = null;
  window.removeEventListener('pointermove', onPointerDragMove);
  window.removeEventListener('pointerup', onPointerDragEnd);
  window.removeEventListener('pointercancel', onPointerDragEnd);
}

/* =========================
   ★④ 仕様変更：スロット上書き時は「自動で空いている場所に移動」をやめる
   + ★追加：完成したら自動でDBへ確定（次フェーズ移行用）
   ========================= */
function placeCardIntoSlot(cardId, toIdx, fromSlotIdx){
  if (!canEditOrder()) return;

  const wasOpen = state.order.open;
  const wasCompleted = state.order.completed;
  const existingIdx = state.order.slots.findIndex(x => x === cardId);
  const originIdx = Number.isInteger(fromSlotIdx) ? fromSlotIdx : (existingIdx >= 0 ? existingIdx : null);
  if (originIdx === toIdx) return;

  const targetCard = state.order.slots[toIdx] || null;

  if (originIdx !== null && originIdx >= 0){
    state.order.slots[toIdx] = cardId;
    state.order.slots[originIdx] = targetCard;
  } else {
    state.order.slots[toIdx] = cardId;
    // 上書きされたカードはスロットから外れるだけ（decided側に戻る）
  }

  const done = state.order.slots.every(v => v);
  state.order.completed = done;

  if (done && !wasCompleted){
    state.order.open = false;
    hideOrderBig();
  } else if (wasOpen || !done){
    showOrderBig();
  } else {
    hideOrderBig();
  }

  renderMyHand();

  // ★完成したら即「確定」してDBへ（全員の完了判定に使う）
  if (done){
    submitMyOrderIfReady();
  }
}

function removeCardFromSlots(cardId){
  if (!canEditOrder()) return;
  const idx = state.order.slots.findIndex(v => v === cardId);
  if (idx >= 0){
    state.order.slots[idx] = null;
    state.order.completed = false;
    showOrderBig();
    renderMyHand();
  }
}

/* ★⑤：外側クリックで閉じる（順カード＆手札以外） */
document.addEventListener('pointerdown', (e) => {
  if (orderBigWrap.classList.contains('hidden')) return;
  if (state.order.dragging) return;
  if (isInsideOrderOrHand(e.target)) return;

  if (state.order.open){
    state.order.open = false;
    hideOrderBig();
    renderMyHand();
  }
}, { capture:true });

/* =========================
   ★小さい順カードを「テキスト配列」から生成（確定済み表示にも使う）
   ========================= */
function buildOrderSmallBlockFromTexts(texts, { clickable }){
  const orderSmallBlock = document.createElement('div');
  orderSmallBlock.className = 'hand-block order-stack';

  const small = document.createElement('div');
  small.className = 'order-card-small';
  small.title = clickable ? 'クリックで拡大（並び替え）' : '確定済み';

  const col = document.createElement('div');
  col.className = 'order-slot-col small';

  for(let i=0;i<5;i++){
    const slot = document.createElement('div');
    slot.className = 'order-slot small';
    injectSlotBorder(slot);

    const t = texts?.[i];
    if (t != null){
      const chip = document.createElement('div');
      chip.className = 'order-in-slot small';
      chip.textContent = String(t);
      slot.appendChild(chip);
    }
    col.appendChild(slot);
  }
  small.appendChild(col);

  if (clickable){
    small.addEventListener('click', (e) => {
      e.stopPropagation();
      showOrderBig();
      renderMyHand();
    });
  } else {
    small.style.cursor = 'default';
  }

  // 左に正体カードを重ねる（従来の見た目維持）
  const roleClone = document.createElement('div');
  roleClone.className = 'role-card-big overlap-left';
  roleClone.textContent = (state.hands?.[state.userId]?.role) ? state.hands[state.userId].role : '（役職なし）';
  orderSmallBlock.appendChild(roleClone);
  orderSmallBlock.appendChild(small);

  return orderSmallBlock;
}

function renderMyHand(){
  cleanupFloatingRole();

  myHandEl.innerHTML = '';
  const myId = state.userId;
  const h = state.hands[myId];
  if (!h){
    hideOrderBig();
    return;
  }

  // ★自分の order 確定状況（DB優先）
  const myOrderFromDb = state.orders?.[myId]?.ordered;
  if (Array.isArray(myOrderFromDb) && myOrderFromDb.length === 5){
    state.order.submitted = true;
    state.order.submittedOrder = myOrderFromDb.slice();
  }

  ensureOrderStateForMyHand(h);

  const phaseDraft = !!state.draft && state.draft.phase === 'draft';
  const draftDone  = !!state.draft && state.draft.phase === 'done';
  const status = state.draft?.status || null;

  const decided = Array.isArray(h.decided) ? h.decided : [];
  const pool = Array.isArray(h.pool) ? h.pool : (Array.isArray(h.cards) ? h.cards : []);
  const pickIdx = Number.isInteger(h.pickIdx) ? h.pickIdx : null;
  const chosen = (pickIdx !== null && pool[pickIdx] != null) ? pool[pickIdx] : null;

  const allPicked = computeAllPicked();
  const canChange = phaseDraft && status === 'picking' && !allPicked;

  const handArea = document.createElement('div');
  handArea.className = 'hand-area';

  /* =========================
     ★正体カードの配置ロジック
     - 順カード拡大中：画面中央の順カードの「左で重ねる」（role-float）
     - 順カード小：順カード小の左に重ねる（overlap-left）
     ========================= */
  const roleCard = document.createElement('div');
  roleCard.className = 'role-card-big';
  roleCard.textContent = h.role ? h.role : '（役職なし）';

  const isOrderBigVisible = !orderBigWrap.classList.contains('hidden');
  const allowOrderSmall = !isOrderBigVisible;

  // 「小さい順カード」が表示される条件
  const isOrderSmallVisible =
    (draftDone && decided.length >= 5 && state.order.completed && !isOrderBigVisible);

  if (isOrderBigVisible){
    roleCard.classList.add('role-float');
    document.body.appendChild(roleCard);
  }

 let orderSmallBlock = null;
  const phase = getRoomPhase();
  const isRevealPhase = (phase === 'reveal');
  const myOrderedTexts = Array.isArray(state.orders?.[myId]?.ordered)
    ? state.orders[myId].ordered.slice()
    : (Array.isArray(state.order.submittedOrder) ? state.order.submittedOrder.slice() : null);

  if (isRevealPhase){
    if (!state.isHost && allowOrderSmall && myOrderedTexts && myOrderedTexts.length === 5){
      orderSmallBlock = buildOrderSmallBlockFromTexts(myOrderedTexts, { clickable: canEditOrder() });
    }
  } else {
    // ★orderフェーズで「確定済み」なら、DBの並びで小カードを出す
    if (allowOrderSmall && draftDone && getRoomPhase() === 'order' && state.order.submitted && Array.isArray(state.order.submittedOrder)){
      orderSmallBlock = buildOrderSmallBlockFromTexts(state.order.submittedOrder, { clickable: canEditOrder() });
    } else if (isOrderSmallVisible){

      // 従来通り（未確定の編集用）
      orderSmallBlock = document.createElement('div');
      orderSmallBlock.className = 'hand-block order-stack';

      const small = document.createElement('div');
      small.className = 'order-card-small';
      small.title = canEditOrder() ? 'クリックで拡大して並び替え' : '確定済み';

      const col = document.createElement('div');
      col.className = 'order-slot-col small';

      for(let i=0;i<5;i++){
        const slot = document.createElement('div');
        slot.className = 'order-slot small';
        injectSlotBorder(slot);

        const cid = state.order.slots[i];
        if (cid){
          const chip = document.createElement('div');
          chip.className = 'order-in-slot small';
          chip.textContent = cardTextById(cid);
          slot.appendChild(chip);
        }
        col.appendChild(slot);
      }
      small.appendChild(col);

      if (canEditOrder()){
        small.addEventListener('click', (e) => {
          e.stopPropagation();
          showOrderBig();
          renderMyHand();
        });
      } else {
        small.style.cursor = 'default';
      }

      const roleClone = document.createElement('div');
      roleClone.className = 'role-card-big overlap-left';
      roleClone.textContent = roleCard.textContent;
      orderSmallBlock.appendChild(roleClone);
      orderSmallBlock.appendChild(small);
    }
  }

  if (!orderSmallBlock && !isOrderBigVisible){
    const rolesBlock = document.createElement('div');
    rolesBlock.className = 'hand-block roles';
    rolesBlock.appendChild(roleCard);
    handArea.appendChild(rolesBlock);
  }

  const decidedBlock = document.createElement('div');
  decidedBlock.className = 'hand-block decided front';

  decidedBlock.addEventListener('dragover', (e) => {
    if (!canEditOrder()) return;
    const payload = safeParseDragPayload(e.dataTransfer?.getData('text/plain') || '');
    if (!payload || payload.type !== 'orderCard') return;
    e.preventDefault();
    decidedBlock.classList.add('drop-over');
  });
  decidedBlock.addEventListener('dragleave', () => decidedBlock.classList.remove('drop-over'));
  decidedBlock.addEventListener('drop', (e) => {
    if (!canEditOrder()) return;
    decidedBlock.classList.remove('drop-over');
    const payload = safeParseDragPayload(e.dataTransfer?.getData('text/plain') || '');
    if (!payload || payload.type !== 'orderCard' || !payload.cardId) return;
    removeCardFromSlots(payload.cardId);
  });

  decided.forEach((v, i) => {
    if (draftDone && decided.length >= 5){
      const cardId = `d${i}`;
      const alreadyPlaced = state.order.slots.includes(cardId);
      if (alreadyPlaced) return;
    }

    const c = document.createElement('div');
    c.className = 'my-card smalltxt disabled';
    c.textContent = v;

    if (draftDone && decided.length >= 5 && canEditOrder()){
      const cardId = `d${i}`;
      c.classList.remove('disabled');
      c.style.cursor = 'grab';
      c.draggable = false;
      c.title = 'ドラッグして順カードの枠へ';
      setupPointerDrag(c, { cardId, fromSlotIdx: null });
    }

    decidedBlock.appendChild(c);
  });

  if (phaseDraft && chosen !== null){
    const c = document.createElement('div');
    c.className = 'my-card smalltxt current' + (canChange ? '' : ' disabled');
    c.textContent = chosen;
    if (canChange){
      c.title = 'クリックで未選択に戻す';
      c.addEventListener('click', async () => {
        await update(ref(db, `rooms/${state.roomCode}/hands/${myId}`), { pickIdx: null });
      });
    }
    decidedBlock.appendChild(c);
  }

  const poolBlock = document.createElement('div');
  poolBlock.className = 'hand-block pool front';

  const poolWrap = document.createElement('div');
  poolWrap.className = 'pool-wrap';

  const passToken = state.draft?.passToken ?? null;
  let shouldAnimatePass = false;
  if (phaseDraft && status === 'passing' && passToken && state._lastPassToken !== passToken){
    shouldAnimatePass = true;
    state._lastPassToken = passToken;
  } else if (phaseDraft && status === 'passing'){
    poolWrap.classList.add('passing-out');
  }

  const incomingToken = state.draft?.incomingToken ?? null;
  if (phaseDraft && status === 'picking' && incomingToken && state._lastIncomingToken !== incomingToken){
    poolWrap.classList.add('incoming');
    state._lastIncomingToken = incomingToken;
    setTimeout(()=> poolWrap.classList.remove('incoming'), 480);
  } else if (!phaseDraft){
    state._lastIncomingToken = incomingToken;
  }

  pool.forEach((v, idx) => {
    if (phaseDraft && chosen !== null && idx === pickIdx) return;
    const c = document.createElement('div');
    const isUndecidedPulse = phaseDraft && status === 'picking';
    c.className = 'my-card smalltxt' + (isUndecidedPulse ? ' undecided' : '');
    c.textContent = v;

    if (!canChange){
      c.classList.add('disabled');
    } else {
      c.title = 'クリックでこのカードを選ぶ（ドラフト）';
      c.addEventListener('click', async () => {
        await update(ref(db, `rooms/${state.roomCode}/hands/${myId}`), { pickIdx: idx });
      });
    }
    poolWrap.appendChild(c);
  });

  poolBlock.appendChild(poolWrap);

  if (orderSmallBlock) handArea.appendChild(orderSmallBlock);
  handArea.appendChild(decidedBlock);
  handArea.appendChild(poolBlock);

  myHandEl.appendChild(handArea);

  if (shouldAnimatePass){
    requestAnimationFrame(() => poolWrap.classList.add('passing-out'));
  }

  requestAnimationFrame(() => fitAllMyCards());

  if ((draftDone && decided.length >= 5) && (state.order.open || !state.order.completed)){
    renderOrderBigSlots();
  }
}

function renderHands(){
  renderMyHand();
  if (latestPlayers.length) renderPlayerCircle(latestPlayers);
}

/* =========================
   ★ミニ順カード（円の外側）生成
   - revealフェーズに入った瞬間に全員表示
   - 他プレイヤーの未公開カードは青塗り
   - ホストは「次に公開できる段」だけクリック可能（どれを押しても全員同段が公開）
   ========================= */
function createMiniOrderOutsideTag({ ordered, pid, angle, isMe, isHost, revealIndex }){
  if (!Array.isArray(ordered) || ordered.length !== 5) return null;

  const wrap = document.createElement('div');
  wrap.className = 'mini-order-wrap';
if (isMe) wrap.classList.add('me');

  const dx = Math.cos(angle);
  const dy = Math.sin(angle);
  const dist = 70;
  wrap.style.transform = `translate(-50%,-50%) translate(${dx*dist}px, ${dy*dist}px)`;

  const card = document.createElement('div');
  card.className = 'mini-order-card';

  const col = document.createElement('div');
  col.className = 'mini-order-col';


  // ★ホスト本人は「未公開の全カード」を公開ボタンにする（公開は上から順番）
  const hostCanOpen = (isHost && isMe && revealIndex < 5);
  for (let i=0;i<5;i++){
    const slot = document.createElement('div');
    slot.className = 'mini-order-slot';
    injectMiniSlotBorder(slot);

    const isRevealed = (i < revealIndex);

    const chip = document.createElement('div');
    chip.className = 'mini-order-chip';

    chip.textContent = String(ordered[i] ?? '');

    if (!isMe && !isRevealed){
      chip.classList.add('hidden-chip');
    }

    // ★ホスト本人の未公開段は全部ボタン（クリックで次の段を公開）
    if (hostCanOpen && i >= revealIndex){
      chip.classList.add('open-btn');
      chip.addEventListener('click', async (e) => {
        e.preventDefault();
        e.stopPropagation();
        await hostRevealNext();
      }, { passive:false });
    }

    slot.appendChild(chip);
    col.appendChild(slot);
  }

  card.appendChild(col);
  if (isMe && canEditOrder()){
    card.classList.add('clickable');
    card.addEventListener('click', (e) => {
      if (e.target?.closest?.('.mini-order-chip')) return;
      e.preventDefault();
      e.stopPropagation();
      showOrderBig();
      renderMyHand();
    });
  }
  wrap.appendChild(card);
  if (!isMe){
    const roleBack = document.createElement('div');
    roleBack.className = 'mini-role-back';
    wrap.appendChild(roleBack);
  }
  return wrap;
}

function injectMiniSlotBorder(slotEl){
  if (slotEl.querySelector('.slot-border')) return;
  const svgNS = "http://www.w3.org/2000/svg";
  const svg = document.createElementNS(svgNS, 'svg');
  svg.classList.add('slot-border');
  svg.setAttribute('viewBox', '0 0 100 100');
  svg.setAttribute('preserveAspectRatio', 'none');

  const path = document.createElementNS(svgNS, 'path');
  path.classList.add('border-path');
  path.setAttribute('d', 'M 99 1 H 19 A 18 18 0 0 0 1 19 V 81 A 18 18 0 0 0 19 99 H 99');
  svg.appendChild(path);
  slotEl.appendChild(svg);
}

function renderPlayerCircle(players){
  playerCircle.innerHTML = '';
  if (!players.length) return;

  const n = players.length;
  const radius = 45;
  const step = (2 * Math.PI) / n;
  const anchorAngle = Math.PI / 2;
  const meIndex = players.findIndex(p => p.id === state.userId);

  const phaseDraft = !!state.draft && state.draft.phase === 'draft';
  const status = state.draft?.status || null;

  const phase = getRoomPhase();
  const inReveal = (phase === 'reveal');
  const revealIndex = getRevealIndex();

  players.forEach((p, idx) => {
    const k = (meIndex === -1) ? idx : (idx - meIndex + n) % n;
    const angle = anchorAngle + step * k;

    const x = 50 + radius * Math.cos(angle);
    const y = 50 + radius * Math.sin(angle);

    const tag = document.createElement('div');
    tag.className = 'player-tag' + (p.id === state.userId ? ' me' : '');
    tag.textContent = p.name;
    tag.style.left = `${x}%`;
    tag.style.top = `${y}%`;

    const h = state.hands[p.id];
    const picked = phaseDraft && status === 'picking' && h && Number.isInteger(h.pickIdx);
    if (picked) tag.classList.add('picked');

    tag.onclick = (e) => {
      // ミニ順カードのクリックが座席奪取に波及しないように
      if (e.target?.closest?.('.mini-order-wrap')) return;

      if (p.id === state.userId) return;
      if (!state.roomCode) return;
      if (state.seatedTable !== null) return;
      pendingSeatIndexToSteal = p.seatIndex;
      pendingSeatPlayerIdToSteal = p.id;
      kickMessage.textContent = `「${p.name}」を追い出して、この席に着席しますか？`;
      kickDialog.classList.remove('hidden');
    };

   if (phaseDraft && p.id !== state.userId && h){
      const decidedCount = Array.isArray(h.decided) ? h.decided.length : 0;
      const placedCount = Array.isArray(state.orders?.[p.id]?.ordered)
        ? state.orders[p.id].ordered.length
        : 0;
      const visibleCount = Math.max(0, decidedCount - placedCount);
      const count = Math.min(5, visibleCount);

      if (count > 0){
        const row = document.createElement('div');
        row.className = 'mini-hand-row';

        const miniHand = document.createElement('div');
        miniHand.className = 'mini-hand';

        const spread = 70;
        const base = (count > 1) ? (-spread/2) : 0;

        for (let i=0;i<count;i++){
          const card = document.createElement('div');
          card.className = 'mini-card';
          card.textContent = '';
          const angleDeg = (count > 1) ? base + (spread/(count-1))*i : 0;
          card.style.transform = `translate(-50%,0) rotate(${angleDeg}deg)`;
          card.style.zIndex = String(10 + i);
          miniHand.appendChild(card);
        }

        row.appendChild(miniHand);
        tag.appendChild(row);
      }
    }

    // ★次フェーズ（reveal）に入ったら、ミニ順カード（配置カード付）を円の外側へ表示
    if (inReveal){
      const isMe = (p.id === state.userId);
      const shouldShowMiniOrder = !(isMe && !state.isHost);
      if (shouldShowMiniOrder){
        const ordered = state.orders?.[p.id]?.ordered;
        const mini = createMiniOrderOutsideTag({
          ordered,
          pid: p.id,
          angle,
          isMe,
          isHost: state.isHost,
          revealIndex
        });
        if (mini){
          // ミニ順カードのクリックが親のonclickに波及しないように
          mini.addEventListener('pointerdown', (e) => e.stopPropagation(), { capture:true });
          tag.appendChild(mini);
        }
      }
    }

    playerCircle.appendChild(tag);
  });
}

const urlParams = new URLSearchParams(window.location.search);
const roomFromUrl = urlParams.get('room');
if(roomFromUrl) inputCode.value = roomFromUrl;

btnJoin.addEventListener('click', async () => {
  state.userName = inputName.value || '名無し';
  state.roomCode = inputCode.value.trim() || generateRoomCode();

  await set(ref(db, `rooms/${state.roomCode}/users/${state.userId}`), {
    name: state.userName,
    joinedAt: Date.now()
  });

  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val();

  if(!roomData || !roomData.hostId){
    await update(roomRef, { hostId: state.userId });
    state.isHost = true;
  } else {
    state.isHost = (roomData.hostId === state.userId);
  }

  updateHostUI();

  mainEl.classList.remove('prejoin');
  mainEl.classList.add('joined');

  joinBox.classList.add('hidden');
  lobby.classList.remove('hidden');
  lobby.classList.add('entered');

  subscribeRoom();
  subscribeHostState();
  subscribePlayers();
  subscribeHands();
  subscribeDraft();
  subscribeOrders(); // ★追加

  syncSeatUI();
});

copyLinkBtn.addEventListener('click', async () => {
  const url = `${location.origin}${location.pathname}?room=${state.roomCode}`;
  try {
    await navigator.clipboard.writeText(url);
    copyLinkBtn.classList.add('copied');
    copyLinkBtn.textContent = 'COPIED';
    inputCode.value = state.roomCode;
    setTimeout(()=>{
      copyLinkBtn.classList.remove('copied');
      copyLinkBtn.textContent='リンクコピー';
    },1500);
  } catch {
    prompt('コピーできません。手動でコピーしてください', url);
  }
});

async function syncSeatUI(){
  if (!state.roomCode) return;
  const maxPlayers = state.room.maxPlayers || null;
  if (!state.isHost && !maxPlayers){
    seatPop.classList.add('hidden');
    return;
  }
  if (state.seatedTable !== null){
    seatPop.classList.add('hidden');
    return;
  }
  await renderSeatTabs();
  seatPop.classList.remove('hidden');
}

async function renderSeatTabs(){
  if (!state.roomCode) return;
  if (isRenderingSeatTabs) return;
  isRenderingSeatTabs = true;

  try {
    seatTabs.innerHTML = '';

    const roomRef = ref(db, `rooms/${state.roomCode}`);
    const roomSnap = await get(roomRef);
    const roomData = roomSnap.val() || {};
    const maxPlayers = roomData.maxPlayers || null;

    if(state.isHost && !maxPlayers){
      seatLabel.textContent = '人数を選択';
      for(let i=2; i<=8; i++){
        const tab = document.createElement('div');
        tab.className = 'tab';
        tab.textContent = i;

        tab.onclick = async () => {
          await update(roomRef, { maxPlayers: i });
          const tRef = ref(db, `rooms/${state.roomCode}/tables/1`);
          await set(tRef, { playerId: state.userId, playerName: state.userName });

          state.seatedTable = 1;
          seatPop.classList.add('hidden');
        };
        seatTabs.appendChild(tab);
      }
      return;
    }

    seatLabel.textContent = '席を選択';

    const effectiveMax = maxPlayers || 8;
    const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const tables = tablesSnap.val() || {};

    for(let i=1; i<=effectiveMax; i++){
      const tab = document.createElement('div');
      tab.className = 'tab';
      tab.textContent = i;

      const t = tables[i];
      if(t && t.playerId) tab.classList.add('disabled');

      tab.onclick = async () => {
        if(tab.classList.contains('disabled')) return;
        const tRef = ref(db, `rooms/${state.roomCode}/tables/${i}`);
        await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });
        state.seatedTable = i;
        seatPop.classList.add('hidden');
      };
      seatTabs.appendChild(tab);
    }
  } finally {
    isRenderingSeatTabs = false;
  }
}

btnSeatCancel.onclick = () => {
  seatPop.classList.add('hidden');
  state.seatedTable = null;
};

function subscribePlayers(){
  const tablesRef = ref(db, `rooms/${state.roomCode}/tables`);
  onValue(tablesRef, async snap => {
    const data = snap.val() || {};
    const players = Object.entries(data)
      .map(([seatIndex, t]) => (t && t.playerId ? {
        id: t.playerId,
        name: t.playerName || '名無し',
        seatIndex: Number(seatIndex)
      } : null))
      .filter(Boolean)
      .sort((a,b) => a.seatIndex - b.seatIndex);

    latestPlayers = players;

    const mySeat = players.find(p => p.id === state.userId);
    if (mySeat && state.seatedTable === null) {
      state.seatedTable = mySeat.seatIndex;
      seatPop.classList.add('hidden');
    }

    const meStillSeated = players.some(p => p.id === state.userId);
    if (!meStillSeated && state.seatedTable !== null) {
      state.seatedTable = null;
    }

    await syncSeatUI();
    renderPlayerCircle(players);
    hostMaybeAdvanceDraft();
    hostMaybeEnsureOrderPhase();
    hostMaybeAdvanceToReveal();
  });
}

kickDialog.addEventListener('click', (e) => {
  if (e.target === kickDialog) {
    kickDialog.classList.add('hidden');
    pendingSeatIndexToSteal = null;
    pendingSeatPlayerIdToSteal = null;
  }
});
btnKickNo.addEventListener('click', (e) => {
  e.stopPropagation();
  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;
});
btnKickYes.addEventListener('click', async (e) => {
  e.stopPropagation();
  if (pendingSeatIndexToSteal == null || !state.roomCode) {
    kickDialog.classList.add('hidden');
    return;
  }

  const seatIndex = pendingSeatIndexToSteal;
  const kickedPlayerId = pendingSeatPlayerIdToSteal;
  const roomRef = ref(db, `rooms/${state.roomCode}`);
  const roomSnap = await get(roomRef);
  const roomData = roomSnap.val() || {};

  if (kickedPlayerId && kickedPlayerId !== state.userId){
    const [handSnap, orderSnap] = await Promise.all([
      get(ref(db, `rooms/${state.roomCode}/hands/${kickedPlayerId}`)),
      get(ref(db, `rooms/${state.roomCode}/orders/${kickedPlayerId}`))
    ]);

    const handData = handSnap.val();
    const orderData = orderSnap.val();
    const updates = {};

    if (handData){
      updates[`rooms/${state.roomCode}/hands/${state.userId}`] = handData;
      updates[`rooms/${state.roomCode}/hands/${kickedPlayerId}`] = null;
    }
    if (orderData){
      updates[`rooms/${state.roomCode}/orders/${state.userId}`] = {
        ...orderData,
        name: state.userName || orderData.name || ''
      };
      updates[`rooms/${state.roomCode}/orders/${kickedPlayerId}`] = null;
    }

    if (Object.keys(updates).length){
      await update(ref(db), updates);
    }
  }

  const tRef = ref(db, `rooms/${state.roomCode}/tables/${seatIndex}`);
  await set(tRef, { playerId: state.userId, playerName: state.userName || '名無し' });

  if (roomData.hostId && pendingSeatPlayerIdToSteal && roomData.hostId === pendingSeatPlayerIdToSteal) {
    await update(roomRef, { hostId: state.userId });
  }

  state.seatedTable = seatIndex;

  kickDialog.classList.add('hidden');
  pendingSeatIndexToSteal = null;
  pendingSeatPlayerIdToSteal = null;

  seatPop.classList.add('hidden');
});

async function dealInitialHandsAndStartDraft(){
  if (!state.roomCode) return;

  const tablesSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
  const tables = tablesSnap.val() || {};

  const players = Object.entries(tables)
    .map(([seatIndex, t]) => (t && t.playerId ? {
      id: t.playerId,
      name: t.playerName || '名無し',
      seatIndex: Number(seatIndex)
    } : null))
    .filter(Boolean)
    .sort((a,b) => a.seatIndex - b.seatIndex);

  if (players.length < 2) return;

  const roleList = makeRoleListForN(players.length);
  const hands = {};
  players.forEach((p, i) => {
    hands[p.id] = {
      role: roleList[i] || ROLE_CARDS[0],
      pool: dealPool5(),
      decided: [],
      pickIdx: null
    };
  });

  const now = Date.now();

  // ★新ゲーム開始：フェーズ初期化 + orders を消す
  await Promise.all([
    set(ref(db, `rooms/${state.roomCode}/hands`), hands),
    set(ref(db, `rooms/${state.roomCode}/draft`), {
      phase: "draft",
      round: 1,
      status: "picking",
      incomingToken: now,
      updatedAt: now
    }),
    update(ref(db, `rooms/${state.roomCode}`), {
      phase: "draft",
      revealIndex: 0
    }),
    remove(ref(db, `rooms/${state.roomCode}/orders`))
  ]);

  // ローカルも初期化
  state.order.decidedKey = null;
  state.order.decidedObjs = [];
  state.order.slots = Array(5).fill(null);
  state.order.completed = false;
  state.order.open = false;
  state.order._autoOpenedOnce = false;
  state.order.submitted = false;
  state.order.submittedOrder = null;
  hideOrderBig();
}

async function hostMaybeAdvanceDraft(){
  if (!state.isHost) return;
  if (!state.roomCode) return;
  if (!state.draft || state.draft.phase !== "draft") return;

  if (state.draft.status === "passing") return;
  if (state.draft.status !== "picking") return;

  const seated = latestPlayers.slice().sort((a,b)=>a.seatIndex-b.seatIndex);
  if (!seated.length) return;

  const allPicked = seated.every(p => {
    const h = state.hands[p.id];
    return h && Number.isInteger(h.pickIdx) && Array.isArray(h.pool) && h.pool.length > 0;
  });
  if (!allPicked) return;

  const passToken = Date.now();
  await update(ref(db, `rooms/${state.roomCode}/draft`), {
    status: "passing",
    passToken,
    updatedAt: passToken
  });

  if (hostPassTimer) clearTimeout(hostPassTimer);

  hostPassTimer = setTimeout(async () => {
    const dSnap = await get(ref(db, `rooms/${state.roomCode}/draft`));
    const d = dSnap.val();
    if (!d || d.phase !== "draft" || d.status !== "passing" || d.passToken !== passToken) return;

    const tSnap = await get(ref(db, `rooms/${state.roomCode}/tables`));
    const t = tSnap.val() || {};
    const order = Object.entries(t)
      .map(([seatIndex, v]) => (v && v.playerId ? { seatIndex:Number(seatIndex), id:v.playerId } : null))
      .filter(Boolean)
      .sort((a,b)=>a.seatIndex-b.seatIndex);

    const hSnap = await get(ref(db, `rooms/${state.roomCode}/hands`));
    const hands = hSnap.val() || {};
    if (order.length < 2) return;

    const remainingById = {};
    const decidedNextById = {};
    order.forEach(({id}) => {
      const h = hands[id];
      const pool = Array.isArray(h?.pool) ? h.pool : [];
      const decided = Array.isArray(h?.decided) ? h.decided : [];
      const pickIdx = Number.isInteger(h?.pickIdx) ? h.pickIdx : null;

      const pickedCard = (pickIdx !== null && pool[pickIdx] != null) ? pool[pickIdx] : null;
      const remain = pool.filter((_, idx) => idx !== pickIdx);

      remainingById[id] = remain;
      decidedNextById[id] = pickedCard ? decided.concat([pickedCard]) : decided.slice();
    });

    const newHands = {};
    for (let i=0;i<order.length;i++){
      const me = order[i].id;
      const next = order[(i+1) % order.length].id;
      const base = hands[me] || {};
      newHands[me] = {
        ...base,
        pool: remainingById[next] || [],
        decided: decidedNextById[me] || [],
        pickIdx: null
      };
    }

    const anyPoolLeft = Object.values(newHands).some(h => Array.isArray(h.pool) && h.pool.length > 0);
    const now = Date.now();

    await set(ref(db, `rooms/${state.roomCode}/hands`), newHands);

    if (!anyPoolLeft){
      await update(ref(db, `rooms/${state.roomCode}/draft`), {
        phase: "done",
        status: "done",
        updatedAt: now
      });

      // ★ドラフト完了：順カード配置フェーズへ
      await update(ref(db, `rooms/${state.roomCode}`), {
        phase: "order",
        revealIndex: 0
      });
    } else {
      await update(ref(db, `rooms/${state.roomCode}/draft`), {
        status: "picking",
        round: (d.round || 1) + 1,
        incomingToken: now,
        updatedAt: now
      });
    }
  }, 1000);
}

hostSettingsBtn.addEventListener('click', () => {
  if (!state.isHost) return;
  startPop.classList.toggle('hidden');
});
btnStartPopClose.addEventListener('click', () => startPop.classList.add('hidden'));
btnGameStart.addEventListener('click', async () => {
  if (!state.isHost) return;
  await dealInitialHandsAndStartDraft();
  startPop.classList.add('hidden');
});
btnResetRoom.addEventListener('click', async () => {
  if (!state.isHost || !state.roomCode) return;
  const base = `rooms/${state.roomCode}`;
  await Promise.all([
    remove(ref(db, `${base}/maxPlayers`)),
    remove(ref(db, `${base}/tables`)),
    remove(ref(db, `${base}/hands`)),
    remove(ref(db, `${base}/draft`)),
    remove(ref(db, `${base}/orders`)),
    remove(ref(db, `${base}/phase`)),
    remove(ref(db, `${base}/revealIndex`))
  ]);
  state.seatedTable = null;
  startPop.classList.add('hidden');

  state.order.decidedKey = null;
  state.order.decidedObjs = [];
  state.order.slots = Array(5).fill(null);
  state.order.completed = false;
  state.order.open = false;
  state.order._autoOpenedOnce = false;
  state.order.submitted = false;
  state.order.submittedOrder = null;
  hideOrderBig();

  await syncSeatUI();
});
</script>

</body>
</html>
